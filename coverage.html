
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/e6a5/passkc/cmd/get.go (64.3%)</option>
				
				<option value="file1">github.com/e6a5/passkc/cmd/keychain.go (0.0%)</option>
				
				<option value="file2">github.com/e6a5/passkc/cmd/modify.go (83.3%)</option>
				
				<option value="file3">github.com/e6a5/passkc/cmd/remove.go (81.8%)</option>
				
				<option value="file4">github.com/e6a5/passkc/cmd/root.go (60.0%)</option>
				
				<option value="file5">github.com/e6a5/passkc/cmd/set.go (28.0%)</option>
				
				<option value="file6">github.com/e6a5/passkc/cmd/show.go (73.7%)</option>
				
				<option value="file7">github.com/e6a5/passkc/kc/kc.go (0.0%)</option>
				
				<option value="file8">github.com/e6a5/passkc/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright © 2023 Hiep Tran &lt;tranhiepqna@gmail.com&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "bufio"
        "encoding/csv"
        "encoding/json"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

type getCmdRunner struct {
        kcManager KeychainManager
}

func (r *getCmdRunner) run(cmd *cobra.Command, args []string) <span class="cov4" title="3">{
        var domain string
        if len(args) &gt; 0 </span><span class="cov4" title="3">{
                domain = args[0]
        }</span> else<span class="cov0" title="0"> {
                // Read from stdin if no domain provided
                scanner := bufio.NewScanner(os.Stdin)
                if scanner.Scan() </span><span class="cov0" title="0">{
                        domain = strings.TrimSpace(scanner.Text())
                }</span>
        }

        <span class="cov4" title="3">if domain == "" </span><span class="cov0" title="0">{
                cmd.PrintErrf("Error: domain is required\n")
                os.Exit(1)
        }</span>

        <span class="cov4" title="3">outputFormat, _ := cmd.Flags().GetString("output")
        quiet, _ := cmd.Flags().GetBool("quiet")

        cred, err := r.kcManager.GetData(domain)
        if err != nil </span><span class="cov0" title="0">{
                cmd.PrintErrf("Error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov4" title="3">switch outputFormat </span>{
        case "json":<span class="cov1" title="1">
                json.NewEncoder(cmd.OutOrStdout()).Encode(cred)</span>
        case "csv":<span class="cov0" title="0">
                w := csv.NewWriter(cmd.OutOrStdout())
                w.Write([]string{cred.Domain, cred.Username, cred.Password})
                w.Flush()</span>
        default:<span class="cov3" title="2">
                if !quiet </span><span class="cov1" title="1">{
                        cmd.Printf("Domain: %s\nUsername: %s\n", cred.Domain, cred.Username)
                }</span>
                <span class="cov3" title="2">cmd.Print(cred.Password)</span>
        }
}

func newGetCmd(kcManager KeychainManager) *cobra.Command <span class="cov10" title="15">{
        runner := &amp;getCmdRunner{
                kcManager: kcManager,
        }
        cmd := &amp;cobra.Command{
                Use:   "get [domain]",
                Short: "Retrieve username and password for a domain from the Keychain",
                Long: `The passkc get command retrieves the stored username and password for a specific domain.
It supports multiple output formats and can be used in pipelines.

Examples:
  # Get credentials in default format
  passkc get domain.com

  # Get credentials in JSON format
  passkc get domain.com -o json

  # Get credentials and pipe to clipboard
  passkc get domain.com | pbcopy

  # Get credentials for domain from stdin
  echo "domain.com" | passkc get`,
                Args: cobra.MaximumNArgs(1),
                Run:  runner.run,
        }
        cmd.Flags().BoolP("password-only", "p", false, "Output only the password")
        return cmd
}</span>

func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(newGetCmd(&amp;LiveKeychainManager{}))
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import "github.com/e6a5/passkc/kc"

// KeychainManager defines the interface for interacting with the keychain.
// This allows for mocking in tests.
type KeychainManager interface {
        ListData() ([]kc.Credential, error)
        GetData(domain string) (*kc.Credential, error)
        SetData(domain, username, password string) error
        RemoveData(domain string) error
}

// LiveKeychainManager is the implementation that uses the real keychain.
type LiveKeychainManager struct{}

func (lkm *LiveKeychainManager) ListData() ([]kc.Credential, error) <span class="cov0" title="0">{
        return kc.ListData()
}</span>

func (lkm *LiveKeychainManager) GetData(domain string) (*kc.Credential, error) <span class="cov0" title="0">{
        return kc.GetData(domain)
}</span>

func (lkm *LiveKeychainManager) SetData(domain, username, password string) error <span class="cov0" title="0">{
        return kc.SetData(domain, username, password)
}</span>

func (lkm *LiveKeychainManager) RemoveData(domain string) error <span class="cov0" title="0">{
        return kc.RemoveData(domain)
}</span>

// newKeychainManager creates a new instance of the live keychain manager.
func newKeychainManager() KeychainManager <span class="cov0" title="0">{
        return &amp;LiveKeychainManager{}
}</span> </pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright © 2023 Hiep Tran &lt;tranhiepqna@gmail.com&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

type modifyCmdRunner struct {
        kcManager KeychainManager
}

func (r *modifyCmdRunner) run(cmd *cobra.Command, args []string) <span class="cov3" title="2">{
        domain := args[0]
        newUsername := args[1]
        quiet, _ := cmd.Flags().GetBool("quiet")

        // We use SetData which will prompt for a password and update if the item exists
        err := r.kcManager.SetData(domain, newUsername, "")
        if err != nil </span><span class="cov0" title="0">{
                cmd.PrintErrf("Error modifying credentials for %s: %v\n", domain, err)
                os.Exit(1)
        }</span>

        <span class="cov3" title="2">if !quiet </span><span class="cov1" title="1">{
                cmd.Printf("Modified credentials for %s successfully\n", domain)
        }</span>
}

func newModifyCmd(kcManager KeychainManager) *cobra.Command <span class="cov10" title="15">{
        runner := &amp;modifyCmdRunner{
                kcManager: kcManager,
        }
        return &amp;cobra.Command{
                Use:   "modify [domain] [new-username]",
                Short: "Modify the username for a domain in the Keychain",
                Long: `The passkc modify command updates the username for a specific domain.
It will prompt for a new password. If you want to change the password, use 'set'.

Examples:
  # Modify the username for a domain
  passkc modify domain.com new-username`,
                Args: cobra.ExactArgs(2),
                Run:  runner.run,
        }
}</span>

func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(newModifyCmd(&amp;LiveKeychainManager{}))

        // Here you will define your flags and configuration settings.

        // Cobra supports Persistent Flags which will work for this command
        // and all subcommands, e.g.:
        // modifyCmd.PersistentFlags().String("foo", "", "A help for foo")

        // Cobra supports local flags which will only run when this command
        // is called directly, e.g.:
        // modifyCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright © 2023 Hiep Tran &lt;tranhiepqna@gmail.com&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

type removeCmdRunner struct {
        kcManager KeychainManager
}

func (r *removeCmdRunner) run(cmd *cobra.Command, args []string) <span class="cov3" title="2">{
        domain := args[0]
        quiet, _ := cmd.Flags().GetBool("quiet")

        err := r.kcManager.RemoveData(domain)
        if err != nil </span><span class="cov0" title="0">{
                cmd.PrintErrf("Error removing credentials for %s: %v\n", domain, err)
                os.Exit(1)
        }</span>

        <span class="cov3" title="2">if !quiet </span><span class="cov1" title="1">{
                cmd.Printf("Removed credentials for %s successfully\n", domain)
        }</span>
}

func newRemoveCmd(kcManager KeychainManager) *cobra.Command <span class="cov10" title="15">{
        runner := &amp;removeCmdRunner{
                kcManager: kcManager,
        }
        return &amp;cobra.Command{
                Use:   "remove [domain]",
                Short: "Remove credentials for a domain from the Keychain",
                Long: `The passkc remove command removes the stored credentials for a specific domain.
This action is irreversible.

Examples:
  # Remove credentials for a domain
  passkc remove domain.com`,
                Args: cobra.ExactArgs(1),
                Run:  runner.run,
        }
}</span>

func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(newRemoveCmd(&amp;LiveKeychainManager{}))

        // Here you will define your flags and configuration settings.

        // Cobra supports Persistent Flags which will work for this command
        // and all subcommands, e.g.:
        // removeCmd.PersistentFlags().String("foo", "", "A help for foo")

        // Cobra supports local flags which will only run when this command
        // is called directly, e.g.:
        // removeCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright © 2023 Hiep Tran &lt;tranhiepqna@gmail.com&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "passkc",
        Short: "A Unix-style password manager using macOS Keychain",
        Long: `passkc is a command-line tool for managing credentials in macOS Keychain.
It follows Unix philosophy by:
- Doing one thing well: managing credentials
- Working with text streams
- Being composable with other tools
- Using plain text interfaces
- Avoiding captive user interfaces

Examples:
  # Get credentials and pipe to clipboard
  passkc get domain.com | pbcopy

  # List credentials and filter
  passkc show | grep "google"

  # Set credentials from file
  passkc set -f credentials.txt

  # Output in JSON format
  passkc show -o json | jq '.[] | select(.domain == "google.com")'`,
        // Uncomment the following line if your bare application
        // has an action associated with it:
        // Run: func(cmd *cobra.Command, args []string) { },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov1" title="1">{
        initializeFlags(rootCmd)
}</span>

func initializeFlags(cmd *cobra.Command) <span class="cov10" title="15">{
        // Global flags
        cmd.PersistentFlags().StringP("output", "o", "text", "Output format (text|json|csv)")
        cmd.PersistentFlags().StringP("config", "c", "", "Config file (default is $HOME/.passkc.yaml)")
        cmd.PersistentFlags().BoolP("quiet", "q", false, "Suppress prompts and non-essential output")

        // Environment variable support
        if domain := os.Getenv("PASSKC_DEFAULT_DOMAIN"); domain != "" </span><span class="cov0" title="0">{
                cmd.PersistentFlags().String("domain", domain, "Default domain to use")
        }</span>

        // Cobra also supports local flags, which will only run
        // when this action is called directly.
        <span class="cov10" title="15">cmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright © 2023 Hiep Tran &lt;tranhiepqna@gmail.com&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "bufio"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

type setCmdRunner struct {
        kcManager KeychainManager
}

func (r *setCmdRunner) run(cmd *cobra.Command, args []string) <span class="cov3" title="2">{
        filePath, _ := cmd.Flags().GetString("file")
        quiet, _ := cmd.Flags().GetBool("quiet")

        if filePath != "" </span><span class="cov0" title="0">{
                // Read credentials from file
                file, err := os.Open(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        cmd.PrintErrf("Error opening file: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                scanner := bufio.NewScanner(file)
                for scanner.Scan() </span><span class="cov0" title="0">{
                        parts := strings.Fields(scanner.Text())
                        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                domain := parts[0]
                                username := parts[1]
                                password := ""
                                if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                                        password = parts[2]
                                }</span>
                                <span class="cov0" title="0">if err := r.kcManager.SetData(domain, username, password); err != nil </span><span class="cov0" title="0">{
                                        cmd.PrintErrf("Error setting credentials for %s: %v\n", domain, err)
                                }</span> else<span class="cov0" title="0"> if !quiet </span><span class="cov0" title="0">{
                                        cmd.Printf("Saved credentials for %s\n", domain)
                                }</span>
                        }
                }
        } else<span class="cov3" title="2"> if len(args) == 2 </span><span class="cov3" title="2">{
                // Set credentials from command line arguments
                domain := args[0]
                username := args[1]
                if err := r.kcManager.SetData(domain, username, ""); err != nil </span><span class="cov0" title="0">{
                        cmd.PrintErrf("Error: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov3" title="2">if !quiet </span><span class="cov1" title="1">{
                        cmd.Println("Saved successfully")
                }</span>
        } else<span class="cov0" title="0"> {
                // Read from stdin
                scanner := bufio.NewScanner(os.Stdin)
                if scanner.Scan() </span><span class="cov0" title="0">{
                        parts := strings.Fields(scanner.Text())
                        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                domain := parts[0]
                                username := parts[1]
                                password := ""
                                if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                                        password = parts[2]
                                }</span>
                                <span class="cov0" title="0">if err := r.kcManager.SetData(domain, username, password); err != nil </span><span class="cov0" title="0">{
                                        cmd.PrintErrf("Error: %v\n", err)
                                        os.Exit(1)
                                }</span>
                                <span class="cov0" title="0">if !quiet </span><span class="cov0" title="0">{
                                        cmd.Println("Saved successfully")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cmd.PrintErrf("Error: invalid input format\n")
                                os.Exit(1)
                        }</span>
                }
        }
}

func newSetCmd(kcManager KeychainManager) *cobra.Command <span class="cov10" title="15">{
        runner := &amp;setCmdRunner{
                kcManager: kcManager,
        }
        cmd := &amp;cobra.Command{
                Use:   "set [domain] [username]",
                Short: "Store credentials for a domain in the Keychain",
                Long: `The passkc set command stores credentials for a domain in the Keychain.
It supports input from file and stdin.

Examples:
  # Set credentials interactively
  passkc set domain.com username

  # Set credentials from file
  passkc set -f credentials.txt

  # Set credentials from stdin
  echo "domain.com username password" | passkc set

  # Set credentials in quiet mode
  passkc set domain.com username -q`,
                Args: cobra.MaximumNArgs(2),
                Run:  runner.run,
        }
        cmd.Flags().StringP("file", "f", "", "Read credentials from file")
        return cmd
}</span>

func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(newSetCmd(&amp;LiveKeychainManager{}))
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright © 2023 Hiep Tran &lt;tranhiepqna@gmail.com&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "encoding/csv"
        "encoding/json"
        "os"
        "sort"
        "strings"

        "github.com/e6a5/passkc/kc"
        "github.com/spf13/cobra"
)

type showCmdRunner struct {
        kcManager KeychainManager
}

func (r *showCmdRunner) run(cmd *cobra.Command, args []string) <span class="cov6" title="5">{
        outputFormat, _ := cmd.Flags().GetString("output")
        pattern, _ := cmd.Flags().GetString("pattern")
        sortBy, _ := cmd.Flags().GetString("sort")
        quiet, _ := cmd.Flags().GetBool("quiet")

        creds, err := r.kcManager.ListData()
        if err != nil </span><span class="cov0" title="0">{
                cmd.PrintErrf("Error: %v\n", err)
                os.Exit(1)
        }</span>

        // Filter credentials if pattern is provided
        <span class="cov6" title="5">if pattern != "" </span><span class="cov1" title="1">{
                filtered := make([]kc.Credential, 0)
                for _, cred := range creds </span><span class="cov3" title="2">{
                        if strings.Contains(cred.Domain, pattern) || strings.Contains(cred.Username, pattern) </span><span class="cov1" title="1">{
                                filtered = append(filtered, cred)
                        }</span>
                }
                <span class="cov1" title="1">creds = filtered</span>
        }

        // Sort credentials
        <span class="cov6" title="5">switch sortBy </span>{
        case "domain":<span class="cov0" title="0">
                sort.Slice(creds, func(i, j int) bool </span><span class="cov0" title="0">{
                        return creds[i].Domain &lt; creds[j].Domain
                }</span>)
        case "username":<span class="cov1" title="1">
                sort.Slice(creds, func(i, j int) bool </span><span class="cov1" title="1">{
                        return creds[i].Username &lt; creds[j].Username
                }</span>)
        }

        // Output in requested format
        <span class="cov6" title="5">switch outputFormat </span>{
        case "json":<span class="cov3" title="2">
                // Ensure we output a valid JSON array even if creds is nil
                if creds == nil </span><span class="cov0" title="0">{
                        creds = make([]kc.Credential, 0)
                }</span>
                <span class="cov3" title="2">json.NewEncoder(cmd.OutOrStdout()).Encode(creds)</span>
        case "csv":<span class="cov0" title="0">
                w := csv.NewWriter(cmd.OutOrStdout())
                w.Write([]string{"Domain", "Username"})
                for _, cred := range creds </span><span class="cov0" title="0">{
                        w.Write([]string{cred.Domain, cred.Username})
                }</span>
                <span class="cov0" title="0">w.Flush()</span>
        default:<span class="cov4" title="3">
                if !quiet </span><span class="cov4" title="3">{
                        cmd.Println("List of credentials:")
                }</span>
                <span class="cov4" title="3">for _, cred := range creds </span><span class="cov6" title="5">{
                        cmd.Printf("%s (%s)\n", cred.Domain, cred.Username)
                }</span>
        }
}

func newShowCmd(kcManager KeychainManager) *cobra.Command <span class="cov10" title="15">{
        runner := &amp;showCmdRunner{
                kcManager: kcManager,
        }
        cmd := &amp;cobra.Command{
                Use:   "show",
                Short: "List all stored credentials",
                Long: `The passkc show command lists all stored credentials.
It supports filtering, sorting, and multiple output formats.

Examples:
  # List all credentials
  passkc show

  # List credentials in JSON format
  passkc show -o json

  # Filter credentials by pattern
  passkc show --pattern "*.com"

  # Sort credentials by domain
  passkc show --sort domain

  # Combine filtering and sorting
  passkc show --pattern "google" --sort username`,
                Run: runner.run,
        }
        cmd.Flags().String("pattern", "", "Filter credentials by pattern")
        cmd.Flags().String("sort", "", "Sort by field (domain|username)")
        return cmd
}</span>

func init() <span class="cov1" title="1">{
        // The real command uses the live keychain manager.
        rootCmd.AddCommand(newShowCmd(&amp;LiveKeychainManager{}))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright © 2023 Hiep Tran &lt;tranhiepqna@gmail.com&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package kc

import (
        "fmt"
        "strings"

        "github.com/keybase/go-keychain"
)

// Credential holds the data for a keychain entry.
type Credential struct {
        Domain   string `json:"domain"`
        Username string `json:"username"`
        Password string `json:"password,omitempty"`
}

// GetData retrieves credentials from the Keychain for a given domain.
// It will find the first entry matching the service "com.passkc.&lt;domain&gt;".
func GetData(domain string) (*Credential, error) <span class="cov0" title="0">{
        query := keychain.NewItem()
        query.SetSecClass(keychain.SecClassGenericPassword)
        query.SetService(fmt.Sprintf("com.passkc.%s", domain))
        query.SetMatchLimit(keychain.MatchLimitAll)

        results, err := keychain.QueryItem(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no credentials found for domain: %s", domain)
        }</span>

        // Get the first result
        <span class="cov0" title="0">result := results[0]
        username := result.Account
        password := string(result.Data)

        return &amp;Credential{
                Domain:   domain,
                Username: username,
                Password: password,
        }, nil</span>
}

// SetData stores credentials in the Keychain.
// If an entry for the service and account already exists, it will be updated.
// If password is an empty string, the user will be prompted to enter it.
func SetData(domain, username, password string) error <span class="cov0" title="0">{
        service := fmt.Sprintf("com.passkc.%s.%s", domain, username)
        
        if password == "" </span><span class="cov0" title="0">{
                // Prompt for password if not provided
                fmt.Print("Enter password: ")
                var input string
                fmt.Scanln(&amp;input)
                password = input
        }</span>

        <span class="cov0" title="0">item := keychain.NewItem()
        item.SetSecClass(keychain.SecClassGenericPassword)
        item.SetService(service)
        item.SetAccount(username)
        item.SetData([]byte(password))
        item.SetAccessible(keychain.AccessibleWhenUnlocked)
        item.SetSynchronizable(keychain.SynchronizableNo)

        err := keychain.AddItem(item)
        if err == keychain.ErrorDuplicateItem </span><span class="cov0" title="0">{
                // Update existing item
                query := keychain.NewItem()
                query.SetSecClass(keychain.SecClassGenericPassword)
                query.SetService(service)
                query.SetAccount(username)
                query.SetMatchLimit(keychain.MatchLimitOne)

                attributes := keychain.NewItem()
                attributes.SetData([]byte(password))

                err = keychain.UpdateItem(query, attributes)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// RemoveData removes all credential entries for a given domain.
func RemoveData(domain string) error <span class="cov0" title="0">{
        query := keychain.NewItem()
        query.SetSecClass(keychain.SecClassGenericPassword)
        query.SetService(fmt.Sprintf("com.passkc.%s", domain))
        query.SetMatchLimit(keychain.MatchLimitAll)

        return keychain.DeleteItem(query)
}</span>

func ListData() ([]Credential, error) <span class="cov0" title="0">{
        query := keychain.NewItem()
        query.SetSecClass(keychain.SecClassGenericPassword)
        query.SetService("com.passkc")
        query.SetMatchLimit(keychain.MatchLimitAll)

        results, err := keychain.QueryItem(query)
        if err == keychain.ErrorItemNotFound </span><span class="cov0" title="0">{
                return make([]Credential, 0), nil // Not an error, just no items
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">creds := make([]Credential, 0)
        for _, result := range results </span><span class="cov0" title="0">{
                // Parse domain and username from service name
                parts := strings.Split(result.Service, ".")
                if len(parts) &gt;= 4 </span><span class="cov0" title="0">{
                        domain := parts[2]
                        username := result.Account
                        creds = append(creds, Credential{
                                Domain:   domain,
                                Username: username,
                        })
                }</span>
        }

        <span class="cov0" title="0">return creds, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright © 2023 Hiep Tran &lt;tranhiepqna@gmail.com&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package main

import "github.com/e6a5/passkc/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
